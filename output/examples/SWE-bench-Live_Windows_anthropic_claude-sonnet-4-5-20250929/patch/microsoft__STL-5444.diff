diff --git a/stl/inc/locale b/stl/inc/locale
index cc08f4d4..bd254251 100644
--- a/stl/inc/locale
+++ b/stl/inc/locale
@@ -94,6 +94,41 @@ inline size_t __CRTDECL _LStrxfrm(_Out_writes_(_Last1 - _First1) _Post_readable_
 }
 #endif // defined(_CRTBLD)
 
+template <class _Elem>
+size_t __CRTDECL _LStrxfrm_primary(_Elem* _First1, _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2,
+    const _Locinfo::_Collvec*) { // perform locale-specific primary transform of _Elems [_First1, _Last1)
+    const ptrdiff_t _Count = _Last2 - _First2;
+    if (_Count <= _Last1 - _First1) {
+        _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));
+    }
+
+    return _Count;
+}
+
+template <>
+inline size_t __CRTDECL _LStrxfrm_primary(_Out_writes_(_Last1 - _First1) _Post_readable_size_(return) char* _First1,
+    _In_z_ char* _Last1, const char* _First2, const char* _Last2,
+    const _Locinfo::_Collvec* _Vector) { // perform locale-specific primary transform of chars [_First1, _Last1)
+    return _Strxfrm_primary(_First1, _Last1, _First2, _Last2, _Vector);
+}
+
+template <>
+inline size_t __CRTDECL _LStrxfrm_primary(_Out_writes_(_Last1 - _First1) _Post_readable_size_(return) wchar_t* _First1,
+    _In_z_ wchar_t* _Last1, const wchar_t* _First2, const wchar_t* _Last2,
+    const _Locinfo::_Collvec* _Vector) { // perform locale-specific primary transform of wchar_ts [_First1, _Last1)
+    return _Wcsxfrm_primary(_First1, _Last1, _First2, _Last2, _Vector);
+}
+
+#ifdef _CRTBLD
+template <>
+inline size_t __CRTDECL _LStrxfrm_primary(_Out_writes_(_Last1 - _First1) _Post_readable_size_(return) unsigned short* _First1,
+    _In_z_ unsigned short* _Last1, const unsigned short* _First2, const unsigned short* _Last2,
+    const _Locinfo::_Collvec* _Vector) { // perform locale-specific primary transform of unsigned shorts [_First1, _Last1)
+    return _Wcsxfrm_primary(reinterpret_cast<wchar_t*>(_First1), reinterpret_cast<wchar_t*>(_Last1),
+        reinterpret_cast<const wchar_t*>(_First2), reinterpret_cast<const wchar_t*>(_Last2), _Vector);
+}
+#endif // defined(_CRTBLD)
+
 _EXPORT_STD template <class _Elem>
 class collate : public locale::facet { // facet for ordering sequences of elements
 public:
@@ -112,6 +147,11 @@ public:
         return do_transform(_First, _Last);
     }
 
+    _NODISCARD string_type transform_primary(const _Elem* _First, const _Elem* _Last) const {
+        // transform [_First, _Last) to primary key string (ignoring case and diacritics)
+        return do_transform_primary(_First, _Last);
+    }
+
     _NODISCARD long hash(const _Elem* _First, const _Elem* _Last) const { // compute hash code for [_First, _Last)
         return do_hash(_First, _Last);
     }
@@ -181,6 +221,27 @@ protected:
         return _Str;
     }
 
+    _NODISCARD virtual string_type __CLR_OR_THIS_CALL do_transform_primary(const _Elem* _First, const _Elem* _Last) const {
+        // transform [_First, _Last) to primary key string (ignoring case and diacritics)
+        _Adl_verify_range(_First, _Last);
+        size_t _Count;
+        string_type _Str;
+
+        for (_Count = static_cast<size_t>(_Last - _First); _Str.size() < _Count;) {
+            // grow string if locale-specific strxfrm fails
+            _Str.resize(_Count);
+            _Count = _LStrxfrm_primary(&_Str[0], &_Str[0] + _Str.size(), _First, _Last, &_Coll);
+
+            if (_Count == static_cast<size_t>(-1)) {
+                // return empty string in case of error
+                _Count = 0;
+                break;
+            }
+        }
+        _Str.resize(_Count);
+        return _Str;
+    }
+
     _NODISCARD virtual long __CLR_OR_THIS_CALL do_hash(const _Elem* _First, const _Elem* _Last) const {
         // compute hash code for [_First, _Last)
         _Adl_verify_range(_First, _Last);
diff --git a/stl/inc/regex b/stl/inc/regex
index b63f7e83..4a951f3c 100644
--- a/stl/inc/regex
+++ b/stl/inc/regex
@@ -310,14 +310,14 @@ public:
 
     template <class _FwdIt>
     string_type transform_primary(_FwdIt _First, _FwdIt _Last) const {
-        // apply locale-specific case-insensitive transformation
+        // apply locale-specific case-insensitive and diacritic-insensitive transformation
         string_type _Res;
 
         if (_First != _Last) { // non-empty string, transform it
             vector<_Elem> _Temp(_First, _Last);
 
             _Getctype()->tolower(_Temp.data(), _Temp.data() + _Temp.size());
-            _Res = _Getcoll()->transform(_Temp.data(), _Temp.data() + _Temp.size());
+            _Res = _Getcoll()->transform_primary(_Temp.data(), _Temp.data() + _Temp.size());
         }
         return _Res;
     }
diff --git a/stl/inc/xlocinfo b/stl/inc/xlocinfo
index 054c2524..0beb01b5 100644
--- a/stl/inc/xlocinfo
+++ b/stl/inc/xlocinfo
@@ -62,6 +62,9 @@ _CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Strcoll(
 _CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Strxfrm(_Out_writes_(_End1 - _String1)
                                                           _Post_readable_size_(return) char* _String1,
     _In_z_ char* _End1, const char*, const char*, const _Collvec*) noexcept;
+_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Strxfrm_primary(_Out_writes_(_End1 - _String1)
+                                                          _Post_readable_size_(return) char* _String1,
+    _In_z_ char* _End1, const char*, const char*, const _Collvec*) noexcept;
 _CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Tolower(int, const _Ctypevec*) noexcept;
 _CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Toupper(int, const _Ctypevec*) noexcept;
 _CRTIMP2_PURE _Success_(return != -1) int __CLRCALL_PURE_OR_CDECL
@@ -71,6 +74,9 @@ _CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Wcscoll(
 _CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Wcsxfrm(_Out_writes_(_End1 - _String1) _Post_readable_size_(return)
                                                           wchar_t* _String1,
     _In_z_ wchar_t* _End1, const wchar_t*, const wchar_t*, const _Collvec*) noexcept;
+_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Wcsxfrm_primary(_Out_writes_(_End1 - _String1) _Post_readable_size_(return)
+                                                          wchar_t* _String1,
+    _In_z_ wchar_t* _End1, const wchar_t*, const wchar_t*, const _Collvec*) noexcept;
 
 _CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Getwctype(wchar_t, const _Ctypevec*) noexcept;
 _CRTIMP2_PURE const wchar_t* __CLRCALL_PURE_OR_CDECL _Getwctypes(
diff --git a/stl/src/xstrxfrm.cpp b/stl/src/xstrxfrm.cpp
index c094a843..9865154e 100644
--- a/stl/src/xstrxfrm.cpp
+++ b/stl/src/xstrxfrm.cpp
@@ -93,4 +93,57 @@ _CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Strxfrm(_Out_writes_(end1 - string
     return retval;
 }
 
+// size_t _Strxfrm_primary() - Transform a string using locale information for primary equivalence
+//
+// Purpose:
+//     Transform the string pointed to by string2 and place the
+//     resulting string into the array pointed to by string1.
+//     This version produces a primary sort key that ignores case and diacritics
+//     for use in regex equivalence class matching.
+//
+//     The transformation uses NORM_IGNORENONSPACE to ignore diacritics.
+//
+_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Strxfrm_primary(_Out_writes_(end1 - string1)
+                                                          _Post_readable_size_(return) char* string1,
+    _In_z_ char* end1, const char* string2, const char* end2, const _Collvec* ploc) noexcept {
+    size_t n1     = end1 - string1;
+    size_t n2     = end2 - string2;
+    size_t retval = static_cast<size_t>(-1); // NON-ANSI: default if OM or API error
+    UINT codepage;
+    const wchar_t* locale_name;
+
+    if (ploc == nullptr) {
+        locale_name = ___lc_locale_name_func()[LC_COLLATE];
+        codepage    = ___lc_collate_cp_func();
+    } else {
+        locale_name = ploc->_LocaleName;
+        codepage    = ploc->_Page;
+    }
+
+    if (locale_name == nullptr && codepage == CP_ACP) {
+        if (n2 <= n1) {
+            memcpy(string1, string2, n2);
+        }
+        retval = n2;
+    } else {
+        // Inquire size of dst string in BYTES
+        // Use NORM_IGNORENONSPACE to ignore diacritics for primary equivalence
+        const int dstlen =
+            __crtLCMapStringA(locale_name, LCMAP_SORTKEY | NORM_IGNORENONSPACE, string2, static_cast<int>(n2), nullptr, 0, codepage, TRUE);
+
+        if (dstlen != 0) {
+            retval = dstlen;
+
+            // if not enough room, return amount needed
+            if (dstlen <= static_cast<int>(n1)) {
+                // Map src string to dst string
+                __crtLCMapStringA(locale_name, LCMAP_SORTKEY | NORM_IGNORENONSPACE, string2, static_cast<int>(n2), string1,
+                    static_cast<int>(n1), codepage, TRUE);
+            }
+        }
+    }
+
+    return retval;
+}
+
 _END_EXTERN_C_UNLESS_PURE
diff --git a/stl/src/xwcsxfrm.cpp b/stl/src/xwcsxfrm.cpp
index 631c735d..56e667f1 100644
--- a/stl/src/xwcsxfrm.cpp
+++ b/stl/src/xwcsxfrm.cpp
@@ -99,12 +99,84 @@ _CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Wcsxfrm(_Out_writes_(end1 - string
     return size;
 }
 
+// size_t _Wcsxfrm_primary() - Transform a string using locale information for primary equivalence
+//
+// Purpose:
+//     Transform the wide string pointed to by string2 and place the
+//     resulting wide string into the array pointed to by string1.
+//     This version produces a primary sort key that ignores case and diacritics
+//     for use in regex equivalence class matching.
+//
+//     The transformation uses NORM_IGNORENONSPACE to ignore diacritics.
+//
+_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Wcsxfrm_primary(_Out_writes_(end1 - string1) _Post_readable_size_(return)
+                                                          wchar_t* string1,
+    _In_z_ wchar_t* end1, const wchar_t* string2, const wchar_t* end2, const _Collvec* ploc) noexcept {
+    size_t n1   = end1 - string1;
+    size_t n2   = end2 - string2;
+    size_t size = static_cast<size_t>(-1);
+    const wchar_t* locale_name;
+
+    if (ploc == nullptr) {
+        locale_name = ___lc_locale_name_func()[LC_COLLATE];
+    } else {
+        locale_name = ploc->_LocaleName;
+    }
+
+    if (locale_name == nullptr) {
+        if (n2 <= n1) {
+            memcpy(string1, string2, n2 * sizeof(wchar_t));
+        }
+        size = n2;
+    } else {
+        // When using LCMAP_SORTKEY, LCMapStringW handles BYTES not wide
+        // chars. We use a byte buffer to hold bytes and then convert the
+        // byte string to a wide char string and return this so it can be
+        // compared using wcscmp(). User's buffer is n1 wide chars, so
+        // use an internal buffer of n1 bytes.
+
+        auto bbuffer = _malloc_crt_t(unsigned char, n1);
+
+        if (bbuffer) {
+#pragma warning(push)
+#pragma warning(disable : 6386) // PREfast doesn't understand LCMAP_SORTKEY
+            // Use NORM_IGNORENONSPACE to ignore diacritics for primary equivalence
+            size = __crtLCMapStringW(locale_name, LCMAP_SORTKEY | NORM_IGNORENONSPACE, string2, static_cast<int>(n2),
+                reinterpret_cast<wchar_t*>(bbuffer.get()), static_cast<int>(n1));
+#pragma warning(pop)
+
+            if (size == 0) {
+                // buffer not big enough, get size required.
+                size = __crtLCMapStringW(locale_name, LCMAP_SORTKEY | NORM_IGNORENONSPACE, string2, static_cast<int>(n2), nullptr, 0);
+
+                if (size == 0) {
+                    size = static_cast<size_t>(-1); // default error
+                }
+            } else {
+                // string successfully mapped, convert to wide char
+
+                for (size_t i = 0; i < size; ++i) {
+                    string1[i] = static_cast<wchar_t>(bbuffer.get()[i]);
+                }
+            }
+        }
+    }
+
+    return size;
+}
+
 #ifdef MRTDLL
 _CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Wcsxfrm(unsigned short* string1, unsigned short* end1,
     const unsigned short* string2, const unsigned short* end2, const _Collvec* ploc) noexcept {
     return _Wcsxfrm(reinterpret_cast<wchar_t*>(string1), reinterpret_cast<wchar_t*>(end1),
         reinterpret_cast<const wchar_t*>(string2), reinterpret_cast<const wchar_t*>(end2), ploc);
 }
+
+_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Wcsxfrm_primary(unsigned short* string1, unsigned short* end1,
+    const unsigned short* string2, const unsigned short* end2, const _Collvec* ploc) noexcept {
+    return _Wcsxfrm_primary(reinterpret_cast<wchar_t*>(string1), reinterpret_cast<wchar_t*>(end1),
+        reinterpret_cast<const wchar_t*>(string2), reinterpret_cast<const wchar_t*>(end2), ploc);
+}
 #endif // defined(MRTDLL)
 
 _END_EXTERN_C_UNLESS_PURE
